use strict;
use warnings;
use utf8;

use Test::More;

use Encode ();

use Tu::Response;
use Tu::ActionResponseResolver;

subtest 'return_undef_on_undef' => sub {
    my $resolver = _build_resolver();

    ok(not defined $resolver->resolve);
};

subtest 'return_arrayref_on_string' => sub {
    my $resolver = _build_resolver();

    is_deeply(
        $resolver->resolve('привет'),
        [
            200,
            ['Content-Type' => 'text/html'],
            [Encode::encode('UTF-8', 'привет')]
        ]
    );
};

subtest 'return_arrayref_on_arrayref' => sub {
    my $resolver = _build_resolver();

    is_deeply($resolver->resolve([200, [], ['body']]), [200, [], ['body']]);
};

subtest 'return_code_on_code' => sub {
    my $resolver = _build_resolver();

    is(ref $resolver->resolve(sub { }), 'CODE');
};

subtest 'return_finalized_object' => sub {
    my $resolver = _build_resolver();

    is_deeply(
        $resolver->resolve(Tu::Response->new(200)),
        [200, ['Content-Type' => 'text/html'], []]
    );
};

subtest 'not returns response object when unknown' => sub {
    my $resolver = _build_resolver();

    ok !$resolver->resolve(TestObject->new);
};

sub _build_resolver {
    my $self = shift;
    my (%params) = @_;

    return Tu::ActionResponseResolver->new(@_);
}

done_testing;

package TestObject;

use strict;
use warnings;

sub new {
    my $class = shift;

    my $self = {};
    bless $self, $class;

    return $self;
}



1;
